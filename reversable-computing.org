#+OPTIONS: html-postamble:<p>Published on <span class="post-footer-date">DATE_HERE</span> by <span class="post-footer-name">Dylan</span></p>
#+TITLE: Reversable Computing
#+SUBTITLE: How to save the universe
#+TAGS: Physics, Mathematics
#+DATE: 20-12-25
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css"/><link href="https://fonts.googleapis.com/css2?family=Ibarra+Real+Nova&display=swap" rel="stylesheet">
#+HTML_HEAD: <div class="navbar"><a href="index.html">Home</a> | <a href="about.html">About</a></div>

* Intro
I was reminded of an interesting concept a few days ago called reversible
computation. I think I first heard about it years ago when I was going though a
period of enormous concern about the heat death of the universe: the prospect
that in the far far future entropy throughout the universe will have increased
to such an extent that there are no temperature gradients, thus no work, thus no
computation, and since computation is presumably necessary for conscious life
there is no possibility of anyone or anything being around to comment on the
dark black inky blankness.

Lots of other people have worried about this too - no less Freeman Dyson, a man
who pops up at alarming frequency throughout the zanier ends of science. He
proposed in the 70s that a simulated race of post humans could actually extend
subjective time infinitely whilst only expending a finite amount of energy
through reversible computation. I caught that reversibility had something to do
with the possibility of input to be entirely reconstructed from the output, and
that this lead to improved efficiency, but my 15 year old mind didn't care so
much about the details and was much set at rest by this clever man saying that
things were going to be fine.

Well this phrase "reversible computing" continued to knock around in my head for
like five years until I eventually regurgitated it to a friend in a discussion
about something or other, which led me to actually clarify my understanding a
bit. This article will hopefully serve as a good tool in recapitulating that
understanding! My presentation style is going to be innovative and stream of
consciousness so its like you're really coming along with me for the ride!

* The Idea
Classical computation is not information-preserving. Obviously, a typical
computer clears registers to make space for more information, etc. In fact, any
system which can be represented by a many-to-one function does not preserve
information - and the nature of typical logic gates are many-to-one. In an OR
gate three of the four unique inputs are assigned a high output, given knowledge
just of the high output we could not know which input it corresponded to. We can
see then how this information loss makes the computation irreversible, and the
irreversibly is enormously compounded by combining these gates together, say to
make an adder. On an abstract level, we can see how simple two figure addition
is already many to one: given the output "8" I can already permute "1 + 7", "2 +
6", "3 + 5", etc as possible inputs.

The concept of information preservation is not so abstruse as it sounds: we just
need to make our functions one-to-one. To do this we simply need to map inputs
to themes plus the result of the operation. For example, the output of "3 + 5"
becomes "3 + 5 AND 8." This preserves a lovely one-to-one mapping and hence
reversibility. If we extended this method to the level of gates themselves we
already have the beginnings of a fully reversible computing machine! To labour
the OR gate example: <1, 1> -> <<1,1> 1>, <1, 0> -> <<1,0> 1>, etc. Although,
the gates which tend to be used in reversible logic tend to be quite different
to this.

Why is this important? Well, this links back to information. As with all
abstract concepts there appear to be a million different interpretations of a
million different formalisations each with their own deep history and
applications. However, in the sense important for reversible computing,
information is something to do with entropy. Entropy is colloquially labelled as
"disorder" and it kind of is, but a lot of things which seem quite ordered to us
are actually high entropy, and vice-versa. The heat death of the universe for
instance is high-entropy despite it not seeming to have a lot going on, and the
start of the universe is low entropy despite it being a big mess.

Entropy, and by extension information, turn out to be pretty subjective
construct relating to how models of systems succeed in representing systems.
Models of systems are said to be "course grained" if they sacrifice description
of individual elements of a system in return for the general behaviour of a
system. This all links back to the evil of statistical mechanics (which I
suppose in some sense itself is a course grained model, whoops). Ideal gas laws
are a good example. There is a lot of shit going on in a gas of uniform
pressure, temperature, etc: probably at least 14 zillion little guys bouncing
around pretty unpredictably. Yet, the ideal gas laws are amazingly simple: PV =
nRT. This description is extremely course-grained, yet it still gives us very
accurate information about the behaviour o f gas under certain conditions. How
many conditions? The individual 14 zillion molecules can be arranged in 323
zingobadrillion different ways and still produce a system accurately described
by our course-grained model, it doesn't really matter if that particular
molecule there is helium or argon - it is the number of ways a system can be
arranged and still conforms to a model that leads to entropy. It is said that
high entropy systems have many microstates corresponding to one macro state.

Contrast the ideal gas scenario to the famously bitchy naiver-stokes equations
describing the flow of a viscous fluid: hey
are just horrendous, horrific, awful and famously shitty to solve. This in some
sense is because viscous fluid flow is a highly structured system: I.E low
entropy. It is highly chaotic: small changes in the positioning of a
(relatively) small number of molecules can enormously change the behaviour of
the overall system. Thus: a finer-grained model is necessary to capture the
behaviour: making it such that fewer microstates that correspond to a
macrostate. Notice here though that the "macrostate" is defined by the model,
and the model is created by humans for some purpose. Entropy increase refers to
a situation where we can acceptably model the changing macrostate in such a way
that the number of microstates corresponding to it increases. I found this
really a revelation and it has certain implications on the flow of time and
other crazy shit. Maybe time is the result of our models of the world changing
in order to more efficiently facilitate predictions : the "easiness" and thus
direction of which is arbitrary. This is a Richenbachean view and I don't know
if its right but its sure as hell hard to prove wrong on his own terms.
* Fuck
Basically though, entropy tends to go up in a closed system: our models tend to
become simpler. This is bad news for life though because models becoming simpler
eventually means that nothing complex happens like life and consciousness and
other cool shit! This goes for any system we want to run forever: entropy needs
to not increase. Thus, if we want a computer to run forever, it needs to operate
in a closed system which entropy does not increase: I.E: the system behaves
exactly like a model. How the fuck do we do that? By preserving all information
within the system! Information here then becomes a sort of interface between
models of different granularity, information "loss" is the disparity of
behaviour between higher and lower grained models. We need to create a
computational system which is so well understood and modelled that there is no
disparity between it and reality (I.E: a perfect model of the universe).
Information erasure within a model of computing necessitates a disparity between
the model of computation and reality: where the information "goes" is
unaccounted for and sorted out by some other physical models. Thus, for a model
of computation to have zero entropy increase it necessarily must preserve
information and hence be reversible. This is all summed up in Landauer’s
Principle which basically stipulates there will always be an energy cost
associated with erasing bits but not necessarily in propagating them.

 Even if we make a computer with reversible logic there are still lots of things
 increasing entropy: resistance in conductors, etc. Using reversible logic
 usually increases the overhead of actually making the damn thing do anything
 useful (not being able to erase bits makes memory management much more
 complicated), so the tradeoff isn't yet worth it. However, if the energy loss
 per computation gets low enough such that the information loss actually becomes
 a significant factor, reversible computing becomes viable. There is actually a
 principal in thermodynamics that basically the slower you run a system the less
 energy loss you are going to get. So, in theory, if we run our computers
 arbitrarily slowly reversibility will actually become a factor (if ran slow
 enough, even the factor) in further improving efficiency. Hense mister Dyson's
 suggestion that we slow down the subjective time of our future simulations so
 we can squeeze the most computation out of the universe as possible!

Interestingly enough, many kinds of quantum computers are also reversible in
nature! This maybe should be expected because entanglement entails a sort of
lack of information leakage from the entangled system. This isn't to say that
all forms of quantum computation are reversible, some have intermediate stages
where qbits are disentangled, etc. And of course the _output_ of a quantum
computer must involve some kind of collapse. Even so, kind of interesting, and
quantum computers have been suggested as a promising route to making a
physically realisable mega efficient computing machine because of this
reversibility. So maybe our decedents will be using suitably futuristic quantum
shit made by Google or IBM or something.

Well that's kind of cool but what does a reversible computer look like?! How do
you program it? How do you use the logic gates? I will explain......

Let me introduce you to some gates:he
input/output schema is given with boolean algebra notation which I didn't know
but its pretty simple. The big letters A, B, C, etc are just boolean variables
which take the value 0 or 1, pretty standard. When you see two together like AB
this is literally multiplication and so the logical operation is a conjunction:
"AND" (I.E 1x1 = 1, 1x0 = 0... logically like a conjunction). "⊕" means "XOR",
"+" "OR", the apostrophe means "not" and there are some others probably but this
is all I have seen and its enough for everything.

Looking at these you can see how you can trace back the output of each gate to
the input. The Feynman gate for example is basically an XOR plus an extra output
(A itself) to keep track of which of A or B was high. The others are a bit more
complicated but in principal, as it tends to be with these sorts of things, can
all be built up from the Feynman gate.

With these you can make a full adder, like these Algerian gentleman did:






 (starting to see some similarities to irreversibility?!) Consideration of this
leads us to entropy. and is hence non-reversible. I was reminded of an
interesting concept a few days ago called reversible computation. I think I
first heard about it years ago when I was going though a period of enormous
concern about the heat death of the universe: the prospect that in the far far
future entropy throughout the universe will have increased to such an extent
that there are no temperature gradients, thus no work, thus no computation, and
since computation is presumably necessary for conscious life there is no
possibility of anyone or anything being around to comment on the dark black inky
blankness.

Lots of other people have worried about this too - no less Freeman Dyson, a man
who pops up at alarming frequency throughout the zanier ends of science. He
proposed in the 70s that a simulated race of post humans could actually extend
subjective time infinitely whilst only expending a finite amount of energy
through reversible computation. I caught that reversibility had something to do
with the possibility of input to be entirely reconstructed from the output, and
that this lead to improved efficiency, but my 15 year old mind didn't care so
much about the details and was much set at rest by this clever man saying that
things were going to be fine.

Well this phrase "reversible computing" continued to knock around in my head for
like five years until I eventually regurgitated it to a friend in a discussion
about something or other, which led me to actually clarify my understanding a
bit. This article will hopefully serve as a good tool in recapitulating that
understanding! My presentation style is going to be innovative and stream of
consciousness so its like you're really coming along with me for the ride!

* The Idea
Classical computation is not information-preserving. Obviously, a typical
computer clears registers to make space for more information, etc. In fact, any
system which can be represented by a many-to-one function does not preserve
information - and the nature of typical logic gates are many-to-one. In an OR
gate three of the four unique inputs are assigned a high output, given knowledge
just of the high output we could not know which input it corresponded to. We can
see then how this information loss makes the computation irreversible, and the
irreversibly is enormously compounded by combining these gates together, say to
make an adder. On an abstract level, we can see how simple two figure addition
is already many to one: given the output "8" I can already permute "1 + 7", "2 +
6", "3 + 5", etc as possible inputs.

The concept of information preservation is not so abstruse as it sounds: we just
need to make our functions one-to-one. To do this we simply need to map inputs
to themes plus the result of the operation. For example, the output of "3 + 5"
becomes "3 + 5 AND 8." This preserves a lovely one-to-one mapping and hence
reversibility. If we extended this method to the level of gates themselves we
already have the beginnings of a fully reversible computing machine! To labour
the OR gate example: <1, 1> -> <<1,1> 1>, <1, 0> -> <<1,0> 1>, etc. Although,
the gates which tend to be used in reversible logic tend to be quite different
to this.

Why is this important? Well, this links back to information. As with all
abstract concepts there appear to be a million different interpretations of a
million different formalisations each with their own deep history and
applications. However, in the sense important for reversible computing,
information is something to do with entropy. Entropy is colloquially labelled as
"disorder" and it kind of is, but a lot of things which seem quite ordered to us
are actually high entropy, and vice-versa. The heat death of the universe for
instance is high-entropy despite it not seeming to have a lot going on, and the
start of the universe is low entropy despite it being a big mess.

Entropy, and by extension information, turn out to be pretty subjective
construct relating to how models of systems succeed in representing systems.
Models of systems are said to be "course grained" if they sacrifice description
of individual elements of a system in return for the general behaviour of a
system. This all links back to the evil of statistical mechanics (which I
suppose in some sense itself is a course grained model, whoops). Ideal gas laws
are a good example. There is a lot of shit going on in a gas of uniform
pressure, temperature, etc: probably at least 14 zillion little guys bouncing
around pretty unpredictably. Yet, the ideal gas laws are amazingly simple: PV =
nRT. This description is extremely course-grained, yet it still gives us very
accurate information about the behaviour o f gas under certain conditions. How
many conditions? The individual 14 zillion molecules can be arranged in 323
zingobadrillion different ways and still produce a system accurately described
by our course-grained model, it doesn't really matter if that particular
molecule there is helium or argon - it is the number of ways a system can be
arranged and still conforms to a model that leads to entropy. It is said that
high entropy systems have many microstates corresponding to one macro state.

Contrast the ideal gas scenario to the famously bitchy naiver-stokes equations
describing the flow of a viscous fluid:hey
are just horrendous, horrific, awful and famously shitty to solve. This in some
sense is because viscous fluid flow is a highly structured system: I.E low
entropy. It is highly chaotic: small changes in the positioning of a
(relatively) small number of molecules can enormously change the behaviour of
the overall system. Thus: a finer-grained model is necessary to capture the
behaviour: making it such that fewer microstates that correspond to a
macrostate. Notice here though that the "macrostate" is defined by the model,
and the model is created by humans for some purpose. Entropy increase refers to
a situation where we can acceptably model the changing macrostate in such a way
that the number of microstates corresponding to it increases. I found this
really a revelation and it has certain implications on the flow of time and
other crazy shit. Maybe time is the result of our models of the world changing
in order to more efficiently facilitate predictions : the "easiness" and thus
direction of which is arbitrary. This is a Richenbachean view and I don't know
if its right but its sure as hell hard to prove wrong on his own terms.

Basically though, entropy tends to go up in a closed system: our models tend to
become simpler. This is bad news for life though because models becoming simpler
eventually means that nothing complex happens like life and consciousness and
other cool shit! This goes for any system we want to run forever: entropy needs
to not increase. Thus, if we want a computer to run forever, it needs to operate
in a closed system which entropy does not increase: I.E: the system behaves
exactly like a model. How the fuck do we do that? By preserving all information
within the system! Information here then becomes a sort of interface between
models of different granularity, information "loss" is the disparity of
behaviour between higher and lower grained models. We need to create a
computational system which is so well understood and modelled that there is no
disparity between it and reality (I.E: a perfect model of the universe).
Information erasure within a model of computing necessitates a disparity between
the model of computation and reality: where the information "goes" is
unaccounted for and sorted out by some other physical models. Thus, for a model
of computation to have zero entropy increase it necessarily must preserve
information and hence be reversible. This is all summed up in Landauer’s
Principle which basically stipulates there will always be an energy cost
associated with erasing bits but not necessarily in propagating them.

 Even if we make a computer with reversible logic there are still lots of things
 increasing entropy: resistance in conductors, etc. Using reversible logic
 usually increases the overhead of actually making the damn thing do anything
 useful (not being able to erase bits makes memory management much more
 complicated), so the tradeoff isn't yet worth it. However, if the energy loss
 per computation gets low enough such that the information loss actually becomes
 a significant factor, reversible computing becomes viable. There is actually a
 principal in thermodynamics that basically the slower you run a system the less
 energy loss you are going to get. So, in theory, if we run our computers
 arbitrarily slowly reversibility will actually become a factor (if ran slow
 enough, even the factor) in further improving efficiency. Hense mister Dyson's
 suggestion that we slow down the subjective time of our future simulations so
 we can squeeze the most computation out of the universe as possible!

Interestingly enough, many kinds of quantum computers are also reversible in
nature! This maybe should be expected because entanglement entails a sort of
lack of information leakage from the entangled system. This isn't to say that
all forms of quantum computation are reversible, some have intermediate stages
where qbits are disentangled, etc. And of course the _output_ of a quantum
computer must involve some kind of collapse. Even so, kind of interesting, and
quantum computers have been suggested as a promising route to making a
physically realisable mega efficient computing machine because of this
reversibility. So maybe our decedents will be using suitably futuristic quantum
shit made by Google or IBM or something.

Well that's kind of cool but what does a reversible computer look like?! How do
you program it? How do you use the logic gates? I will explain......

Let me introduce you to some gates: he
input/output schema is given with boolean algebra notation which I didn't know
but its pretty simple. The big letters A, B, C, etc are just boolean variables
which take the value 0 or 1, pretty standard. When you see two together like AB
this is literally multiplication and so the logical operation is a conjunction:
"AND" (I.E 1x1 = 1, 1x0 = 0... logically like a conjunction). "⊕" means "XOR",
"+" "OR", the apostrophe means "not" and there are some others probably but this
is all I have seen and its enough for everything.

Looking at these you can see how you can trace back the output of each gate to
the input. The Feynman gate for example is basically an XOR plus an extra output
(A itself) to keep track of which of A or B was high. The others are a bit more
complicated but in principal, as it tends to be with these sorts of things, can
all be built up from the Feynman gate.

With these you can make a full adder, like these Algerian gentleman did:
